[
    {
      "id": 1,
      "title": "Reverse Vowels in a String",
      "difficulty": "Medium",
      "tags": ["String", "Two Pointers"],
      "description": "Write a function to reverse only the vowels in a given string.",
      "testCases": [
        { "input": "\"hello\"", "output": "\"holle\"" },
        { "input": "\"leetcode\"", "output": "\"leotcede\"" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public String reverseVowels(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
        "javascript": "/\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function(s) {\n    \n};"
      }
    },
    {
      "id": 2,
      "title": "Two Sum",
      "difficulty": "Easy",
      "tags": ["Array", "Hash Map"],
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "testCases": [
        { "input": "[2,7,11,15], 9", "output": "[0,1]" },
        { "input": "[3,2,4], 6", "output": "[1,2]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "javascript": "/\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};"
      }
    },
    {
      "id": 3,
      "title": "Longest Palindromic Substring",
      "difficulty": "Medium",
      "tags": ["String", "Dynamic Programming"],
      "description": "Given a string s, return the longest palindromic substring in s.",
      "testCases": [
        { "input": "\"babad\"", "output": "\"bab\"" },
        { "input": "\"cbbd\"", "output": "\"bb\"" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ",
        "javascript": "/\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    \n};"
      }
    },
    {
      "id": 4,
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "tags": ["Array", "Two Pointers"],
      "description": "Find two lines that together with the x-axis form a container, such that the container contains the most water.",
      "testCases": [
        { "input": "[1,8,6,2,5,4,8,3,7]", "output": "49" },
        { "input": "[1,1]", "output": "1" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        \n    }\n};",
        "java": "class Solution {\n    public int maxArea(int[] height) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "javascript": "/\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function(height) {\n    \n};"
      }
    },
    {
      "id": 5,
      "title": "Add Two Numbers",
      "difficulty": "Medium",
      "tags": ["Linked List", "Math"],
      "description": "Add two numbers represented by linked lists, and return the sum as a linked list.",
      "testCases": [
        { "input": "[2,4,3], [5,6,4]", "output": "[7,0,8]" },
        { "input": "[0], [0]", "output": "[0]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
        "java": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n /\n/*\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    \n};"
      }
    },
    {
      "id": 6,
      "title": "Find Median from Data Stream",
      "difficulty": "Hard",
      "tags": ["Heap", "Design"],
      "description": "Design a data structure that supports finding the median in constant time.",
      "testCases": [
        { "input": "[[1],[2],[\"findMedian\"],[3],[\"findMedian\"]]", "output": "[null,null,1.5,null,2]" }
      ],
      "boilerplate": {
        "cpp": "class MedianFinder {\npublic:\n    MedianFinder() {\n        \n    }\n\n    void addNum(int num) {\n        \n    }\n\n    double findMedian() {\n        \n    }\n};",
        "java": "class MedianFinder {\n    public MedianFinder() {\n        \n    }\n\n    public void addNum(int num) {\n        \n    }\n\n    public double findMedian() {\n        \n    }\n}",
        "python": "class MedianFinder(object):\n    def _init_(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        \n\n    def addNum(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: None\n        \"\"\"\n        \n\n    def findMedian(self):\n        \"\"\"\n        :rtype: float\n        \"\"\"\n        ",
        "javascript": "var MedianFinder = function() {\n    \n};\n\n/\n * @param {number} num\n * @return {void}\n /\nMedianFinder.prototype.addNum = function(num) {\n    \n};\n\n/*\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function() {\n    \n};"
      }
    },
    {
      "id": 7,
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "tags": ["String", "Stack"],
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "testCases": [
        { "input": "\"()\"", "output": "true" },
        { "input": "\"()[]{}\"", "output": "true" },
        { "input": "\"(]\"", "output": "false" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        ",
        "javascript": "/\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};"
      }
    },
    {
      "id": 8,
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "tags": ["Linked List", "Recursion"],
      "description": "Merge two sorted linked lists and return it as a sorted list.",
      "testCases": [
        { "input": "[1,2,4], [1,3,4]", "output": "[1,1,2,3,4,4]" },
        { "input": "[], []", "output": "[]" },
        { "input": "[], [0]", "output": "[0]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
        "java": "class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n /\n/*\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar mergeTwoLists = function(l1, l2) {\n    \n};"
      }
    },
    {
      "id": 9,
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "Medium",
      "tags": ["String", "Sliding Window"],
      "description": "Find the length of the longest substring without repeating characters.",
      "testCases": [
        { "input": "\"abcabcbb\"", "output": "3" },
        { "input": "\"bbbbb\"", "output": "1" },
        { "input": "\"pwwkew\"", "output": "3" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "javascript": "/\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    \n};"
      }
    },
    {
      "id": 10,
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "tags": ["Array", "Binary Search"],
      "description": "Given the array nums after the rotation, find the index of a given target.",
      "testCases": [
        { "input": "[4,5,6,7,0,1,2], 0", "output": "4" },
        { "input": "[4,5,6,7,0,1,2], 3", "output": "-1" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};",
        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
        "javascript": "/\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};"
      }
    },
    {
      "id": 11,
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "tags": ["Dynamic Programming"],
      "description": "You are climbing a staircase. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "testCases": [
        { "input": "2", "output": "2" },
        { "input": "3", "output": "3" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};",
        "java": "class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "javascript": "/\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};"
      }
    },
    {
      "id": 12,
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "tags": ["Array", "Dynamic Programming"],
      "description": "Find the contiguous subarray (containing at least one number) which has the largest sum.",
      "testCases": [
        { "input": "[-2,1,-3,4,-1,2,1,-5,4]", "output": "6" },
        { "input": "[1]", "output": "1" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "javascript": "/\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    \n};"
      }
    },
    {
      "id": 13,
      "title": "Product of Array Except Self",
      "difficulty": "Medium",
      "tags": ["Array"],
      "description": "Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].",
      "testCases": [
        { "input": "[1,2,3,4]", "output": "[24,12,8,6]" },
        { "input": "[0,0]", "output": "[0,0]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def productExceptSelf(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
        "javascript": "/\n * @param {number[]} nums\n * @return {number[]}\n */\nvar productExceptSelf = function(nums) {\n    \n};"
      }
    },
    {
      "id": 14,
      "title": "Binary Tree Inorder Traversal",
      "difficulty": "Easy",
      "tags": ["Tree", "Stack"],
      "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
      "testCases": [
        { "input": "[1,null,2,3]", "output": "[1,3,2]" },
        { "input": "[]", "output": "[]" },
        { "input": "[1]", "output": "[1]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n /\n/*\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    \n};"
      }
    },
    {
      "id": 15,
      "title": "Same Tree",
      "difficulty": "Easy",
      "tags": ["Tree", "Depth-First Search"],
      "description": "Given the roots of two binary trees, write a function to check if they are the same or not.",
      "testCases": [
        { "input": "[1,2,3], [1,2,3]", "output": "true" },
        { "input": "[1,2], [1,null,2]", "output": "false" },
        { "input": "[1,2,1], [1,1,2]", "output": "false" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n /\n/*\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    \n};"
      }
    },
    {
      "id": 16,
      "title": "Symmetric Tree",
      "difficulty": "Easy",
      "tags": ["Tree", "Breadth-First Search"],
      "description": "Given the root of a binary tree, check whether it is a mirror of itself (symmetric around its center).",
      "testCases": [
        { "input": "[1,2,2,3,4,4,3]", "output": "true" },
        { "input": "[1,2,2,null,3,null,3]", "output": "false" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n /\n/*\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    \n};"
      }
    },
    {
      "id": 17,
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "tags": ["Tree", "Breadth-First Search"],
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "testCases": [
        { "input": "[3,9,20,null,null,15,7]", "output": "[[3],[9,20],[15,7]]" },
        { "input": "[1]", "output": "[[1]]" },
        { "input": "[]", "output": "[]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n    }\n};",
        "java": "class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n /\n/*\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function(root) {\n    \n};"
      }
    },
    {
      "id": 18,
      "title": "Convert Sorted Array to Binary Search Tree",
      "difficulty": "Easy",
      "tags": ["Tree", "Divide and Conquer"],
      "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
      "testCases": [
        { "input": "[-10,-3,0,5,9]", "output": "[0,-3,9,-10,null,5]" },
        { "input": "[1,3]", "output": "[3,1]" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        \n    }\n};",
        "java": "class Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n /\n/*\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n    \n};"
      }
    },
    {
      "id": 19,
      "title": "Path Sum",
      "difficulty": "Easy",
      "tags": ["Tree", "Depth-First Search"],
      "description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.",
      "testCases": [
        { "input": "[5,4,8,11,null,13,4,7,2,null,null,null,1], 22", "output": "true" },
        { "input": "[1,2,3], 5", "output": "false" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        ",
        "javascript": "/\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n /\n/*\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, targetSum) {\n    \n};"
      }
    },
    {
      "id": 20,
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "tags": ["String", "Stack"],
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
      "testCases": [
        { "input": "\"()\"", "output": "true" },
        { "input": "\"()[]{}\"", "output": "true" },
        { "input": "\"(]\"", "output": "false" }
      ],
      "boilerplate": {
        "cpp": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};",
        "java": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}",
        "python": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        ",
        "javascript": "/\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    \n};"
      }
    }
  ]